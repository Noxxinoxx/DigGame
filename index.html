<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r124/three.min.js"></script>
   
   
</head>
  <body>
    
    <script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js'></script>
  <script src='https://threejs.org/examples/js/controls/TrackballControls.js'></script>
  <script>
  {var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='//mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);}
  /**
  * Generate a scene object with a background color
  **/
  var points = []
  var coordsx = []
  var coordsz = []
  function getScene() {
    var scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
    return scene;
  }

  /**
  * Generate the camera to be used in the scene. Camera args:
  *   [0] field of view: identifies the portion of the scene
  *     visible at any time (in degrees)
  *   [1] aspect ratio: identifies the aspect ratio of the
  *     scene in width/height
  *   [2] near clipping plane: objects closer than the near
  *     clipping plane are culled from the scene
  *   [3] far clipping plane: objects farther than the far
  *     clipping plane are culled from the scene
  **/
  



  function getCamera() {
    var aspectRatio = window.innerWidth / window.innerHeight;
    var camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 10000);
    camera.position.set(0,150,400);
    camera.lookAt(scene.position);  
    return camera;
  }

  /**
  * Generate the light to be used in the scene. Light args:v
  *   [0]: Hexadecimal color of the light
  *   [1]: Numeric value of the light's strength/intensity
  *   [2]: The distance from the light where the intensity is 0
  * @param {obj} scene: the current scene object
  **/

  function getLight(scene) {
    var lights = [];
    lights[0] = new THREE.PointLight( 0xffffff, 0.6, 0 );
    lights[0].position.set( 100, 200, 100 );
    scene.add( lights[0] );

    var ambientLight = new THREE.AmbientLight(0x111111);
    scene.add(ambientLight);
    return light;
  }

  /**
  * Generate the renderer to be used in the scene
  **/

  function getRenderer() {
    // Create the canvas with a renderer
    var renderer = new THREE.WebGLRenderer({antialias: true});
    // Add support for retina displays
    renderer.setPixelRatio(window.devicePixelRatio);
    // Specify the size of the canvas
    renderer.setSize(window.innerWidth, window.innerHeight);
    // Add the canvas to the DOM
    document.body.appendChild(renderer.domElement);
    return renderer;
  }

  /**
  * Generate the controls to be used in the scene
  * @param {obj} camera: the three.js camera for the scene
  * @param {obj} renderer: the three.js renderer for the scene
  **/

  function getControls(camera, renderer) {
    var controls = new THREE.TrackballControls(camera, renderer.domElement);
    controls.zoomSpeed = 0.4;
    controls.panSpeed = 0.4;
    return controls;
  }
  function Collison(scene, px,py,pz) {
    
   
    points.push(new THREE.Vector3(px * 100,py,pz * 100))
    points.push(new THREE.Vector3(sphereGroup.position.x, sphereGroup.position.y, sphereGroup.position.z))
    const geometry = new THREE.BufferGeometry().setFromPoints( points );
    const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
    const line = new THREE.Line(geometry, material)
    scene.add(line)
    return line
    
  }
  /**
  * Get grass
  **/

  function getsky(scene, loader, x, z, y, side) {
    var texture = loader.load('sky.jpeg');
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
    texture.repeat.set( 10, 10 );
    var material = new THREE.MeshBasicMaterial({
      map: texture, side: side
    });
    var geometry = new THREE.PlaneGeometry(100, 100, 100, 10);
    var plane = new THREE.Mesh(geometry, material);
    plane.position.y = y
    plane.position.z = 100 * z
    plane.position.x = 100 * x;
    plane.rotation.x = Math.PI / 2;
    scene.add(plane);
    return plane;
  }
  function getPlane(scene, loader, x, z,y, side) {
    var texture = loader.load('floor.jpeg');
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
    texture.repeat.set( 10, 10 );
    var material = new THREE.MeshBasicMaterial({
      map: texture, side: side
    });
    var geometry = new THREE.PlaneGeometry(100, 100, 100, 10);
    var plane = new THREE.Mesh(geometry, material);
    plane.position.y = y
    plane.position.z = 100 * z
    plane.position.x = 100 * x;
    plane.rotation.x = Math.PI / 2;
    scene.add(plane);
    return plane;
  }
  //inte optimalt renderings system.
  //det är ett optimerat system nu men man måste hardcoda hur står spelyta man har detta gör det svårt att ändra saker ingame sen
  //men jag har en mattematisk formel för att göra detta så jag kommer implementera det senare så kommer man inte behöva räkna själv.
  //update rendersystement funkar nu. Nu måste jag bara fixa lite lag det gör jag genom att ändra textuernas infalls
  //upplösning till något som passar three js bättre.
  //optmisera med hjälp av mindre figurer de behöver inte vara så stora de kan bara vara några pixlar styck.
  function renderGround(scene, loader, y, side) {
    var z = 0;
    var n = 0;
    var r1 = [
      1,1,1,1,2,
      1,1,1,1,2,
      1,1,1,1,2,
      1,1,1,1,
              ]
    var x = 0;
    var firstItorantion = true;
    for(i = 0; i <= r1.length; i++) {
      
      if(r1[i] == 2) {
        if(firstItorantion == true) {
          var gg = i + 1;
          firstItorantion = false;
        }
        x = x + 1
        n = x * gg
      }else if(r1[i] == 0) {
        z = i - n 
        getsky(scene, loader, x, z, y) 
        coordsx.push(x)
        coordsz.push(z)
        

      }else if(r1[i] == 3) {
        coordsx.push(x)
        coordsz.push(z)
        
      }
      else {
        z = i - n 
        getPlane(scene, loader, x, z, y, side)
        coordsx.push(x)
        coordsz.push(z)
        
      }
      
    }
    
    for(i = 0; i < coordsx.length; i++) {
      t = true;
      Collison(scene, coordsx[i], -50, coordsz[i])
    }
    
  }
  /**
  * Add background
  **/
 // skirv i logboken felkälla att de inte går static tal utan de går från dynamisck tal.
 // folrmen för att lösa detta var (1000 * längden av array) - 500 för att centrera väggarena.
 // render function funkar glöm inte att uppdatera logboken så det ser bra ut. uträningen för den här denlen är enkel
 // men kommer behöva lite förendingar.
 // Måste gör ett collsion system.
  function getBackground(scene, loader) {
    
    var r = [1,1,1,1]
    var l = [1,1,1,1]
    var u = [1,1,1,1]
    var b = [1,1,1,1]
    var imagePrefix = '';
    var directions  = ['right', 'left', 'top', 'bottom', 'front', 'back'];
    var imageSuffix = '.bmp';
    
    var texture = loader.load("WallTextureStone.jpeg")
    for(iu = 0; iu < r.length; iu++) {
      var geometry = new THREE.PlaneGeometry( 100, 100, 100 );
      var material = new THREE.MeshBasicMaterial({map:texture, side: THREE.BackSide})
      var skyr = new THREE.Mesh( geometry, material );
      
      scene.add(skyr);
      skyr.position.x = 100 * iu;
      skyr.position.z = (100 * r.length) - 50
    }for(ib = 0; ib < l.length; ib++) {
     
      var geometry = new THREE.PlaneGeometry( 100, 100, 100 );
      var material = new THREE.MeshBasicMaterial({map:texture, side: THREE.BackSide})
      var skyl = new THREE.Mesh( geometry, material );
      
      scene.add(skyl);
      
      skyl.rotation.y = Math.PI / 2 
      skyl.position.z = 100 * ib;
      skyl.position.x = (100 * l.length) - 50 
      
    }
    
    for(ir = 0; ir < r.length; ir++) {
      var geometry = new THREE.PlaneGeometry( 100, 100, 100 );
      var material = new THREE.MeshBasicMaterial({map:texture, side: THREE.FrontSide})
      var skyr = new THREE.Mesh( geometry, material );
      
      scene.add(skyr);
      skyr.position.x = 100 * ir;
      skyr.position.z = -50
    }for(il = 0; il < l.length; il++) {
     
      var geometry = new THREE.PlaneGeometry( 100, 100, 100);
      var material = new THREE.MeshBasicMaterial({map:texture, side: THREE.FrontSide})
      var skyl = new THREE.Mesh( geometry, material );
      
      scene.add(skyl);
      
      skyl.rotation.y = Math.PI / 2 
      skyl.position.z = 100 * il;
      skyl.position.x = -50
      
    }
  }

  /**
  * Add a character
  **/

  function getSphere(scene) {
    var geometry = new THREE.SphereGeometry( 3, 1.2, 0.9 );
    var material = new THREE.MeshPhongMaterial({
      color: 0xd0901d,
      emissive: 0xaf752a,
      side: THREE.FrontSide,
      flatShading: true
    });
    var sphere = new THREE.Mesh( geometry, material );

    // create a group for translations and rotations
    var sphereGroup = new THREE.Group();
    sphereGroup.add(sphere)

    sphereGroup.position.set(0, -45, 100);
    
    scene.add(sphereGroup);
    return [sphere, sphereGroup];
  }

  /**
  * Store all currently pressed keys
  **/

  function addListeners() {
    window.addEventListener('keydown', function(e) {
      pressed[e.key.toUpperCase()] = true;
    })
    window.addEventListener('keyup', function(e) {
      pressed[e.key.toUpperCase()] = false;
    })
  }

  /**
  * Update the sphere's position
  **/

  function moveSphere() {
    
    var delta = clock.getDelta(); // seconds
    var moveDistance = 20 * delta; // 200 pixels per second
    var rotateAngle = Math.PI / 2 * delta; // pi/2 radians (90 deg) per sec
    var speed = 3; 
    // move forwards/backwards/left/right
    if ( pressed['W'] ) {
      sphere.rotateOnAxis(new THREE.Vector3(1,0,0), -rotateAngle)
      sphereGroup.translateZ( -moveDistance );
    }
    if ( pressed['S'] ) 
      sphereGroup.translateZ(  moveDistance );
    if ( pressed['Q'] )
      sphereGroup.translateX( -moveDistance );
    if ( pressed['E'] )
      sphereGroup.translateX(  moveDistance ); 

    // rotate left/right/up/down
    var rotation_matrix = new THREE.Matrix4().identity();
    if ( pressed['A'] )
      sphereGroup.rotateOnAxis(new THREE.Vector3(0,1,0), rotateAngle);
    if ( pressed['D'] )
      sphereGroup.rotateOnAxis(new THREE.Vector3(0,1,0), -rotateAngle);
    if ( pressed['R'] )
      sphereGroup.rotateOnAxis(new THREE.Vector3(1,0,0), rotateAngle);
    if ( pressed['F'] )
      sphereGroup.rotateOnAxis(new THREE.Vector3(1,0,0), -rotateAngle);
    
    if(pressed[" "]){
      if(globalJump == true) {
        sphereGroup.position.y += speed * (2000) * delta;
        console.log(sphereGroup.position.y)
        globalJump = false
        setTimeout(() => {
          globalJump = true;
        }, 1000)
      } 
    }
  }

  /**
  * Follow the sphere
  **/
  
  function moveCamera() {
    var relativeCameraOffset = new THREE.Vector3(0,5,20);
    var cameraOffset = relativeCameraOffset.applyMatrix4(sphereGroup.matrixWorld);
    camera.position.x = cameraOffset.x;
    camera.position.y = cameraOffset.y;
    camera.position.z = cameraOffset.z;
    camera.lookAt(sphereGroup.position);
  }
  

  // Render loop
  function render() {
    requestAnimationFrame(render);
    renderer.render(scene, camera);
    moveSphere();
    moveCamera();
    gravety()
    
  };
  function gravety() {
    if(sphereGroup.position.y > -45) {
      sphereGroup.position.y -= 5
    }
  }

  // state
  var pressed = {};
  var clock = new THREE.Clock();
  
  // globals
  
  var globalJump = true;
  var scene = getScene();
  var camera = getCamera();
  var light = getLight(scene);
  var renderer = getRenderer();
  
  var gobalJump = true; 

  // add meshes
  var loader = new THREE.TextureLoader();
  var background = getBackground(scene, loader);
  var sphereData = getSphere(scene);
  var sphere = sphereData[0];
  var sphereGroup = sphereData[1];
  
  var floor = renderGround(scene, loader, -50, THREE.BackSide)
  var ceiling = renderGround(scene, loader, 50, THREE.FrontSide)
  
  
  addListeners();
  render();

  </script>
  <p style="margin-left: 150px; margin-top:-690px; position: absolute; z-index: 0; font-size: 40; font-family: Arial, Helvetica, sans-serif;">Time : 60</p>
  </body>
</html>
